# Взаимодействие с графическим интерфейсом

Этот документ находится в разработке.

Функция `loop()` является основной функцией где размещается код выполнения вашей задачи, так же как это делается в обычном скетче Arduino IDE. Так же она должна содержать команду вызова обработчика библиотеки `RemoteXY.h` . 

```
void loop() 
{ 
  RemoteXY_Handler ();

  // TODO you loop code
}
```

Что бы взаимодействовать с графическим интерфейсом, необходимо взаимодействовать с полями структуры RemoteXY. Каждое поле структуры отражает переменную связанную со своим элементом управления. Записывая и считывая значения переменных вы получаете доступ к состоянию элементов управления графического интерфейса.

Все поля структуры делятся на входные и выходные. 

- **input** - данные преимущественно передаются из графического интерфейса в контроллер, но могут передаваться и в обратном направлении. Вы можете считывать значения этих переменных получая текущее состояние элемента управления как взаимодействует с ним пользователь. На запись значений накладываются некоторые ограничения.
- **output** - данные всегда передаются из контроллера в графический интерфейс. В контроллере можно свободно изменять значения этих переменных. При считывании данных вы получите предыдущее записанное значение.

Чтобы передать значение в элемент графического интерфейса, запишите это значение в соответствующее поле структуры.

```
void loop() 
{ 
  RemoteXY_Handler ();

  RemoteXY.temperature = getTemp ();
}
```

Что бы определить в каком состоянии находится элемент графического интерфейса, или какие данные ввел пользователь, прочитайте значение из соответствующего поля структуры.

```
void loop() 
{ 
  RemoteXY_Handler ();

  if (RemoteXY.switch == 1) handleMyProcess ();
}
```

#### Изменить состояние input переменной из контроллера.

Состояние входной переменной может быть изменено из контроллера. Тем самым вы можете установить элемент управления в нужное вам состояние. Например вы можете установить переключатель в положение включен даже без пользователя. Для пользователя это будет выглядеть как будто переключатель переключился сам. Вы так же должны понимать, что пользователь в графическом интерфейсе может изменить состояние элемента управления в тот же момент времени. 

Что бы изменить состояние элемента управления достаточно записать значение нового состояния в связанную переменную. В этот момент запустится процесс обратной передачи информации. Пока состояние такого элемента управления передается по каналу связи в мобильное приложение, контроллер не будет получать новые данные о состоянии этого элемента, даже если пользователь изменит его из графического интерфейса. 

Такое новое значение должно быть записано в переменную только один раз и только в момент когда такая необходимость появилась. Если записывать новое значение входной переменной в каждом цикле контроллера, то пользователь никогда не сможет изменить состояние этого элемента управления из графического интерфейса. 

***Внимание**.* Изменяйте состояние входной переменной на стороне контроллера только тогда и в тот момент времени когда это необходимо, делайте это один раз.

#### Программирование без задержек

Функция `RemoteXY_Handler ();` должна вызываться регулярно и достаточно часто, в каждом цикле `loop ()`. 

От мобильного приложения поступают различные данные. Эти данные сохраняются в буферы, которые есть у каждого коммуникационного канала связи. Когда вы вызываете обработчик `RemoteXY_Handler ();` происходит считывание данных из буферов и их расшифровка. Если обработчик не будет вызываться своевременно, то буферы будут переполняться и данные будут потеряны. Это приведет к сбою связи. Важно не использовать длительные задержки между вызовом обработчика. 

Если какая либо часть кода выполняется достаточно длительное время, предусмотрите вызов обработчика прямо из нее.

Замените все вызовы функции `delay ()` на вызов функции `RemoteXY_delay()` . Эта функция содержит в себе периодический вызов обработчика  `RemoteXY_Handler ();` пока длится задержка в выполнении кода.

Попробуйте изменить ваш код таким образом что бы вам не нужно было использовать функцию  `delay ()` совсем. Обычно это делается с использованием текущего времени контроллера и подсчета интервалов времени вызывая функцию`millis ()`. Так ваш код станет более отзывчивым. Если ваш код находится в паузе `delay ()` он не может реагировать на какие либо события. Вы так же можете пропустить действие пользователя в графическом интерфейсе и обработать его не своевременно.

