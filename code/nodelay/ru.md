# Программирование без задержек

Функция `RemoteXY_Handler ();` должна вызываться регулярно и достаточно часто, в каждом цикле `loop ()`. 

```
void loop() 
{ 
  RemoteXY_Handler ();
}
```

От мобильного приложения поступают различные данные. Эти данные сохраняются в буферы, которые есть у каждого коммуникационного канала связи. Когда вы вызываете обработчик `RemoteXY_Handler ();` происходит считывание данных из буферов и их расшифровка. Если обработчик не будет вызываться своевременно, то буферы будут переполняться и данные будут потеряны. Это приведет к сбою связи. Важно не использовать длительные задержки между вызовом обработчика. 

Если какая либо часть кода выполняется достаточно длительное время, предусмотрите вызов обработчика прямо из нее.

Замените все вызовы функции `delay ()` на вызов функции `RemoteXY_delay()` . Эта функция содержит в себе периодический вызов обработчика  `RemoteXY_Handler ();` пока длится задержка в выполнении кода.

```
void loop() 
{ 
  RemoteXY_Handler ();
  
  if (RemoteXY.button != 0) {
    digitalWrite (LED_BUILTIN, HIGH);  
    RemoteXY_delay (1000);  // wait for a second
    digitalWrite (LED_BUILTIN, LOW);   
    RemoteXY_delay (1000);  // wait for a second
    digitalWrite (LED_BUILTIN, HIGH);  
    RemoteXY_delay (1000);  // wait for a second
    digitalWrite (LED_BUILTIN, LOW);   
  }
}
```

Имейте ввиду что использование `RemoteXY_delay()` гарантирует только то что связь с контроллером не будет разорвана из за переполнения буфера. Однако ваш код все еще на паузе и не реагирует на внешние события и на события в графическом интерфейсе. В предыдущем примере код не будет реагировать на нажатие кнопки целых 3 секунды.

#### Не используйте паузы совсем

Если ваш код находится в паузе он не может реагировать на какие либо события. Попробуйте изменить ваш код таким образом что бы вам не нужно было использовать функцию  `delay()` или `RemoteXY_delay()` совсем. Обычно это делается с использованием текущего времени контроллера `millis ()` и подсчета интервалов времени. Так же вам понадобится переменная в которой будет храниться текущее состояние. Следующий пример показывает как предыдущий код сделать более отзывчивым. 

```
int ledState = 0;
uint32_t ledTime = 0;

void loop() 
{ 
  RemoteXY_Handler ();
  
  uint32_t currentMillis = millis();
  
  if (RemoteXY.button == 1) {
    ledState = 1;
    ledTime = currentMillis;
  }
  
  if (ledState > 0) {
    if (currentMillis - ledTime > 1000) {
      ledState = ledState + 1;
      ledTime = currentMillis;
      if (ledState == 4) {
        ledState = 0;
      }
    }
  }
  
  if ((ledState == 1) || (ledState == 3)) {
    digitalWrite (LED_BUILTIN, HIGH); 
  }
  else {
    digitalWrite (LED_BUILTIN, LOW); 
  }

}
```

